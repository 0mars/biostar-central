"""
Model definitions.

Note: some models are denormalized by design, this greatly simplifies (and speeds up) 
the queries necessary to fetch a certain entry.

"""
from django.db import models
from django.contrib.auth.models import User, Group
from django.contrib import admin

from datetime import datetime
from main.server import html

# import all constants
from main.server.const import *

import markdown

class UserProfile( models.Model ):
    """
    Stores user options

    >>> user, flag = User.objects.get_or_create(first_name='Jane', last_name='Doe', username='jane', email='jane')
    >>> prof = user.get_profile()
    >>> prof.json = dict( message='Hello world' )
    >>> prof.save()
    """
    user  = models.OneToOneField(User, unique=True, related_name='profile')
    score = models.IntegerField(default=0, blank=True)
    views = models.IntegerField(default=0, blank=True)
    bronze_badges = models.IntegerField(default=0)
    silver_badges = models.IntegerField(default=0)
    gold_badges   = models.IntegerField(default=0)
    json  = models.TextField(default="", null=True)
    last_visited = models.DateTimeField(auto_now=True)
    type  = models.IntegerField(choices=USER_TYPES, default=USER_NORMAL)
    about_me = models.TextField(default="", null=True)
    location = models.TextField(default="", null=True)
    website  = models.URLField(default="", null=True, max_length=100)
    openid   = models.URLField(default="http://www.biostars.org", null=True)
    display_name  = models.CharField(max_length=35, default='User', null=False)
    last_login_ip = models.IPAddressField(default="0.0.0.0", null=True)
    openid_merge  = models.NullBooleanField(default=False, null=True)
    
    @property
    def permissions(self):
        perms = EVERYONE_PERM[:]
        if self.type == USER_ADMIN:
            perms.extend(ADMIN_PERM)
        if self.type == USER_MODERATOR or self.type == USER_ADMIN:
            perms.extend(MODERATOR_PERM)
        for perm, rep in REPUTATION_PERM.items():
            if self.score >= rep or self.type == USER_ADMIN or self.type == USER_MODERATOR:
                perms.append(perm)
        return perms
    
    @property
    def is_moderator(self):
        return (self.type == USER_MODERATOR) or (self.type == USER_ADMIN)
    
    @property
    def is_admin(self):
        return self.type == USER_ADMIN

class Tag(models.Model):
    name = models.TextField(max_length=50)
    count = models.IntegerField(default=0)
    
class TagAdmin(admin.ModelAdmin):
    list_display = ('name', 'count')

admin.site.register(Tag, TagAdmin)

class ModLog(models.Model):
    """
    Logs moderator actions
    """
    target = models.ForeignKey(User)
    action = models.CharField(max_length=100, default='')
    text   = models.CharField(max_length=1000, default='')
    other  = models.CharField(max_length=1000, default='') # for know we'll keep this generic
    date   = models.DateTimeField()

class Post(models.Model):
    """
    A posting is the basic content generated by a user
    
    >>> user, flag = User.objects.get_or_create(first_name='Jane', last_name='Doe', username='jane', email='jane')
    >>> post = Post.objects.create(author=user)
    >>> content ='*A*'
    >>> post.create_revision(content=content)
    >>> post.html
    u'<p><em>A</em></p>'
    """
    author = models.ForeignKey(User)
    content = models.TextField(blank=True) # The underlying Markdown
    html    = models.TextField(blank=True) # this is the sanitized HTML for display
    title   = models.TextField(blank=True)
    tag_string = models.CharField(max_length=200) # The tag string is the canonical form of the post's tags
    tag_set = models.ManyToManyField(Tag) # The tag set is built from the tag string and used only for fast filtering
    views = models.IntegerField(default=0, blank=True)
    score = models.IntegerField(default=0, blank=True)
    comment_count = models.IntegerField(default=0)
    revision_count = models.IntegerField(default=0)
    creation_date = models.DateTimeField()
    lastedit_date = models.DateTimeField()
    lastedit_user = models.ForeignKey(User, related_name='editor')
    deleted = models.BooleanField()
    closed = models.BooleanField()

    # this field will be used to allow questions to float back into relevance
    touch_date = models.DateTimeField() 
    
    def create_revision(self, content=None, title=None, tag_string=None, author=None, date=None):
        """
        Creates a new revision of the post with the given data.
        Content, title and tags are assumed to be unmodified if not given.
        Author is assumed to be same as original author if not given.
        Date is assumed to be now if not given.
        """
        content = content or self.content
        title = title or self.title
        tag_string = tag_string or self.tag_string
        author = author or self.author
        date = date or datetime.now()
        
        # transform the content to UNIX style line endings
        content = content.replace('\r\n', '\n')
        content = content.replace('\r', '\n')
        #content = "\n".join( content.splitlines() )
        
        # creates a new revision for the post

        revision = PostRevision(post=self, content=content, tag_string=tag_string, title=title, author=author, date=date)
        revision.save()
                
        # Update our metadata
        self.lastedit_user = author
        
        # convert the markdown to HTML
        self.html = html.generate(content)
        self.content = content
        self.title = title
        self.set_tags(tag_string)
        self.save()

    def current_revision(self):
        """
        Returns the most recent revision of the post. Primarily useful for getting the
        current raw text of the post
        """
        return self.revisions.order_by('date')[0]
        
    def moderator_action(self, action, author, date=None):
        """
        Performs a moderator action on the post. Takes an action (one of REV_ACTIONS)
        and a user. Date is assumed to be now if not provided
        """
        
        text_action = REV_ACTION_MAP.get(action, '')
        text = "%s (id=%s) applied %s (%s) to post id=%s" % (author.profile.display_name, author.id, text_action, action, self.id)
        log  = ModLog(target=author, text=text, action=action, date=date, other=self.id)
        log.save()

        if action == REV_CLOSE:
            self.closed = True
        elif action == REV_REOPEN:
            self.closed = False
        elif action == REV_DELETE:
            self.deleted = True
        elif action == REV_UNDELETE:
            self.deleted = False
        else:
            pass
        self.save()

    def authorize(self, request, strict=False):
        "Verfifies access by a request object. Strict mode fails immediately."
        cond1 = request.user == self.author
        cond2 = request.user.is_staff
        valid = cond1 or cond2
        if strict and not valid:
            raise Exception("Access Denied!")
        return valid

    def get_vote(self, user, vote_type):
        if user.is_anonymous():
            return None
        try:
            return self.votes.get(author=user, type=vote_type)
        except Vote.DoesNotExist:
            return None
        
    def add_vote(self, user, vote_type):
        vote = Vote(author=user, type=vote_type, post=self)
        vote.save()
        return vote
        
    def remove_vote(self, user, vote_type):
        ''' Removes a vote from a user of a certain type if it exists
        Returns True if removed, False if it didn't exist'''
        vote = self.get_vote(user, vote_type)
        if vote:
            vote.delete()
            return True
        return False
    
    def get_comments(self):
        return self.comments.select_related('post','post__author').all()
        
    def set_tags(self, tag_string):
        ''' Sets the post's tags to a space-separated string of tags '''
        self.tag_string = tag_string
        self.save()
        self.tag_set.clear()
        if not tag_string:
            return
        tags = []
        for tag_name in tag_string.split(' '):
            try:
                tags.append(Tag.objects.get(name=tag_name))
            except Tag.DoesNotExist:
                tag = Tag(name=tag_name)
                tag.save()
                tags.append(tag)
        self.tag_set.add(*tags)
        
        
    def get_tags(self):
        ''' Returns the post's tags as a list of strings '''
        return self.tag_string.split(' ')
    
    def details(self):
        return
    
class PostAdmin(admin.ModelAdmin):
    list_display = ('id', 'title', )

admin.site.register(Post, PostAdmin)

        
class PostRevision(models.Model):
    """
    Represents various revisions of a single post
    """
    post    = models.ForeignKey(Post, related_name='revisions')
    
    content = models.TextField()
    tag_string = models.CharField(max_length=200)
    title = models.TextField(blank=True)
    
    # Moderator action performed in this revision, if applicable
    action = models.IntegerField(choices=REV_ACTIONS, default=REV_NONE)
    
    author = models.ForeignKey(User)
    date = models.DateTimeField()
    
    def to_html(self):
        '''We won't cache the HTML in the DB because revisions are viewed fairly infrequently '''
        return html.generate(self.content)
        
    def get_tags(self):
        ''' Returns the revision's tags as a list of strings '''
        return self.tag_string.split(' ')
    
    def apply(self, dir=1):
        self.post.revision_count += dir
        self.post.save()

class PostManager(models.Manager):
    ''' Used for all posts (question, answer, comment); returns only non-deleted posts '''
    def get_query_set(self):
        return super(PostManager, self).get_query_set().select_related('post').filter(post__deleted=False)
        
class Question(models.Model):
    """
    A Question is Post with answers
    
    >>> user, flag = User.objects.get_or_create(first_name='Jane', last_name='Doe', username='jane', email='jane')
    >>> post = Post.objects.create(author=user)
    >>> post.create_revision(content='ABC')
    >>> question, flag = Question.objects.get_or_create(post=post)
    >>> question.post.set_tags("snp codon microarray")
    """
    answer_count = models.IntegerField(default=0, blank=True)
    post = models.OneToOneField(Post, related_name='question')
    lastedit_date = models.DateTimeField(auto_now=True)
    answer_accepted = models.BooleanField(default=False)
    
    all_objects = models.Manager()
    objects = PostManager()
    
    def authorize(self, request, strict=False):
        return self.post.authorize(request, strict=strict)

class Answer(models.Model):
    """
    An answer is a post that connects to a question
    """
    question = models.ForeignKey(Question, related_name='answers')
    post = models.OneToOneField(Post, related_name='answer')
    lastedit_date = models.DateTimeField(auto_now=True)
    accepted = models.BooleanField(default=False)
    
    all_objects = models.Manager()
    objects = PostManager()
    
    def author(self):
        return self.post.author

    def authorize(self, request, strict=False):
        return self.post.authorize(request, strict=strict)
        
    def apply(self, dir=1):
        self.question.answer_count += dir
        self.question.save()
        

class Comment(models.Model):
    """
    Represents a comment to any post (question, answer)
    """
    parent = models.ForeignKey(Post, related_name='comments')
    post = models.OneToOneField(Post, related_name='comment')
    lastedit_date = models.DateTimeField(auto_now=True)
    
    all_objects = models.Manager()
    objects = PostManager()
    
    def apply(self, dir=1):
        ''' Updates the parent post's comment count '''
        self.parent.comment_count += dir
        self.parent.save()

class Vote(models.Model):
    """
    >>> user, flag = User.objects.get_or_create(first_name='Jane', last_name='Doe', username='jane', email='jane')
    >>> post = Post.objects.create(author=user)
    >>> post.create_revision(content='ABC')
    >>> vote = Vote(author=user, post=post, type=VOTE_UP)
    >>> vote.score()
    1
    """
    author = models.ForeignKey(User)
    post = models.ForeignKey(Post, related_name='votes')
    type = models.IntegerField(choices=VOTE_TYPES)
    
    def score(self):
        return POST_SCORE.get(self.type, 0)
    
    def reputation(self):
        return USER_REP.get(self.type, 0)
        
    def voter_reputation(self):
        return VOTER_REP.get(self.type, 0)
    
    def apply(self, dir=1):
        "Applies the score and reputation changes. Direction can be set to -1 to undo (ie delete vote)"
        if self.reputation():
            prof = self.post.author.get_profile()
            prof.score += dir * self.reputation()
            prof.save()
        
        if self.voter_reputation():
            prof = self.author.get_profile()
            prof.score += dir * self.voter_reputation()
            prof.save()

        if self.score():
            self.post.score += dir * self.score()
            self.post.save()
            
        if self.type == VOTE_ACCEPT:
            answer = self.post.answer
            question = answer.question
            if dir == 1:
                answer.accepted = True
                question.answer_accepted = True
            else:
                answer.accepted = False
                question.answer_accepted = False
            answer.save()
            question.save()
            
BADGE_BRONZE, BADGE_SILVER, BADGE_GOLD = 0, 1, 2
BADGE_TYPES = ((BADGE_BRONZE, 'bronze'), (BADGE_SILVER, 'silver'), (BADGE_GOLD, 'gold'))
            
class Badge(models.Model):
    name = models.CharField(max_length=50)
    description = models.CharField(max_length=200)
    type = models.IntegerField(choices=BADGE_TYPES)
    unique = models.BooleanField() # Unique badges may be earned only once
    secret = models.BooleanField() # Secret badges are not listed on the badge list
    count = models.IntegerField(default=0) # Total number of times awarded
    
class Award(models.Model):
    ''' A badge being awarded to a user.Cannot be ManyToManyField
    because some may be earned multiple times'''
    badge = models.ForeignKey(Badge)
    user = models.ForeignKey(User)
    date = models.DateTimeField()
    
    def apply(self, dir=1):
        type = self.badge.type
        prof = self.user.get_profile()
        if type == BADGE_BRONZE:
            prof.bronze_badges += dir
        if type == BADGE_SILVER:
            prof.silver_badges += dir
        if type == BADGE_GOLD:
            prof.gold_badges += dir
        prof.save()
        self.badge.count += dir
        self.badge.save()
    


#
# most of the site functionality, reputation change
# and voting is auto applied via database signals
#
# data migration will need to route through
# these models (this application) to ensure that all actions
# get applied properly
#
from django.db.models import signals


#
# Many models have apply() methods that need to be called when they are created
# and called with dir=-1 when deleted to update something.
#

MODELS_WITH_APPLY = [ Vote, Award, Comment, Answer, PostRevision ]
    
def apply_instance(sender, instance, created, raw, *args, **kwargs):
    "Applies changes from an instance with an apply() method"
    if created and not raw: # Raw is true when importing from fixtures, in which case votes are already applied
        instance.apply()

def unapply_instance(sender, instance,  *args, **kwargs):
    "Unapplies an instance when it is deleted"
    instance.apply(-1)
    
for model in MODELS_WITH_APPLY:
    signals.post_save.connect(apply_instance, sender=model)
    signals.post_delete.connect(unapply_instance, sender=model)
    
# Other objects have more unique signals
def create_profile(sender, instance, created, *args, **kwargs):
    "Post save hook for creating user profiles on user save"
    if created:
        UserProfile.objects.create( user=instance )

def create_post(sender, instance, *args, **kwargs):
    "Pre save post information that needs to be applied"
    if not hasattr(instance, 'lastedit_user'):
        instance.lastedit_user = instance.author
    if not instance.creation_date:
        instance.creation_date = datetime.now()
    if not instance.lastedit_date:
        instance.lastedit_date = datetime.now()
    
    # automatically make it float to relevance upon editing
    instance.touch_date = instance.lastedit_date
    
def create_award(sender, instance, *args, **kwargs):
    "Pre save award function"
    if not instance.date:
        instance.date = datetime.now()
        
def tags_changed(sender, instance, action, pk_set, *args, **kwargs):
    "Applies tag count updates upon post changes"
    if action == 'post_add':
        for pk in pk_set:
            tag = Tag.objects.get(pk=pk)
            tag.count += 1
            tag.save()
    if action == 'post_delete':
        for pk in pk_set:
            tag = Tag.objects.get(pk=pk)
            tag.count -= 1
            tag.save()
    if action == 'pre_clear': # Must be pre so we know what was cleared
        for tag in instance.tag_set.all():
            tag.count -= 1
            tag.save()
            
def tag_created(sender, instance, created, *args, **kwargs):
    "Zero out the count of a newly created Tag instance to avoid double counting in import"
    if created and instance.count != 0:
        # To avoid infinite recursion, we must disconnect the signal temporarily
        signals.post_save.disconnect(tag_created, sender=Tag)
        instance.count = 0
        instance.save()
        signals.post_save.connect(tag_created, sender=Tag)

# now connect all the signals
signals.post_save.connect( create_profile, sender=User )
signals.pre_save.connect( create_post, sender=Post )
signals.pre_save.connect( create_award, sender=Award )

signals.m2m_changed.connect( tags_changed, sender=Post.tag_set.through )
signals.post_save.connect( tag_created, sender=Tag )
