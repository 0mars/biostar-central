INPUT_DATA = {{data.value}}
INPUT_SAMPLE_INFO = {{sampleinfo.value}}
TRIM_QUALITY = {{trim_quality.value}}
TRIM_PRIMER = {{ trim_primer.value }}
THREADS = {{ threads.value}}

#
# Internal parameters after this.
#
DATA_DIR = data
ANALYSIS_DIR = analysis
RESULT_DIR  = results
ERR_LOG = stderr.txt

FASTQC_DIR =$(ANALYSIS_DIR)/fastqc
PTRIM_DIR = $(ANALYSIS_DIR)/trim/trimp
QTRIM_DIR = $(ANALYSIS_DIR)/trim/trimq
UPDATED_SAMPLE_INFO = updated_sampleinfo.txt
#
# commands to run
#
{%  if trim_primer.value == True  and  trim_quality.value != None  %}
all : trim_primer trim_quality
{%  elif trim_primer.value == True %}
all: trim_primer
{%  else %}
all : trim_quality
{%  endif %}



extract:
	#
	# extract data	
	#
	tar -xzvf $(INPUT_DATA)

#
# ============== Update sample sheet ==============
# Read1 and Read2 file names will be added to updated samplesheet.
#

updated_sample_info: extract
	#
	# Make new sample sheet named $(UPDATED_SAMPLE_INFO)
	#
	python -m pipeline.data.samplesheet $(INPUT_SAMPLE_INFO) $(DATA_DIR) > $(UPDATED_SAMPLE_INFO)


#
# ============== Quality reports ==============
#

fastqc: updated_sample_info
	#
	# create fastqc reports of all samples.
	#
	mkdir -p $(FASTQC_DIR)
	cat $(UPDATED_SAMPLE_INFO) | parallel --verbose --progress -j $(THREADS) --header : --colsep '\t' fastqc \
	--nogroup -o $(FASTQC_DIR) $(DATA_DIR)/{file1} $(DATA_DIR)/{file2}

$(RESULT_DIR):
	mkdir -p $(RESULT_DIR)


multiqc: fastqc $(RESULT_DIR)
	#
	# run multiqc to create an aggregate report
	#
	multiqc -f -n input_multiqc -o $(FASTQC_DIR) $(FASTQC_DIR)
	cp $(FASTQC_DIR)/input_multiqc.html $(RESULT_DIR)
	#
	# clean
	#
	#rm -f $(FASTQC_DIR)/*fastqc.zip

#
# =============== Primer trimming =============
# Trim primer sequence included in the samplesheet.
#


trim_primer: $(RESULT_DIR) updated_sample_info
	echo "trimming primer"
	#
	mkdir -p $(PTRIM_DIR)/logs
	#
	# trim left primer
	mkdir -p $(RESULT_DIR)
	cat $(UPDATED_SAMPLE_INFO) |parallel --verbose --progress -j $(THREADS)  --header : --colsep '\t' bbduk.sh \
	in1=$(DATA_DIR)/{file1} in2=$(DATA_DIR)/{file2} \
	out1=$(PTRIM_DIR)/{sample_name}_R1_trimp.fq.gz \
	out2=$(PTRIM_DIR)/{sample_name}_R2_trimp.fq.gz \
	literal={fwd_primer},{rev_primer} ktrim=l k=15 hdist=1 tpe tbo  \
	overwrite=t stats=$(PTRIM_DIR)/logs/{sample_name}_trimp_stats.txt
	#
	# clean
	#
	cat $(PTRIM_DIR)/logs/*stats.txt > $(RESULT_DIR)/trimp_stats.txt

#
# =============== Quality trimming ===================
# Trim reads to user specified threshold value.
#
ifeq ($(wildcard $(PTRIM_DIR)),)
INDIR=$(DATA_DIR)
R1={file1}
R2={file2}
else
INDIR=$(PTRIM_DIR)
R1={sample_name}_R1_trimp.fq.gz
R2={sample_name}_R2_trimp.fq.gz
endif

trim_quality: $(RESULT_DIR) updated_sample_info
	echo $(INDIR),$(R1)
	cat  $(UPDATED_SAMPLE_INFO) |parallel --verbose --progress -j $(THREADS) --header : --colsep '\t' bbduk.sh \
	in1=$(INDIR)/$(R1) in2=$(INDIR)/$(R2) \
	qtrim=rl trimq=$(TRIM_QUALITY)  minlength=35 overwrite=true \
	out1=$(QTRIM_DIR)/{sample_name}_R1_trim.fq.gz \
	out2=$(QTRIM_DIR)/{sample_name}_R2_trim.fq.gz stats=$(QTRIM_DIR)/logs/{sample_name}_stats.txt
	cat $(QTRIM_DIR)/logs/*stats.txt > $(RESULT_DIR)/trimq_stats.txt
	#
	# quality report
	#
	ls $(QTRIM_DIR)/*gz | parallel --verbose --progress -j 8 fastqc --nogroup {} -o $(QTRIM_DIR)
	multiqc -n trim_multiqc --force -o $(QTRIM_DIR) $(QTRIM_DIR)
	cp $(QTRIM_DIR)/trim_multiqc.html $(RESULT_DIR)

